# 实验02：阈值修复

## 实验目的

修复热图生成中的阈值逻辑错误（归一化+高百分位导致GT区域被排除），并找到最优阈值配置。

## 问题背景

实验4.1发现：**60%样本的GT区域相似度低于背景**，75%阈值会排除所有GT区域。

原始阈值逻辑的错误：
```python
# 错误逻辑
heatmap_norm = (heatmap - min) / (max - min)  # 归一化0-1
threshold = np.percentile(heatmap_norm, 75)   # 75%ile ≈ 0.81
mask = (heatmap_norm >= threshold)             # GT全部被排除
```

## 代码修改

### 修改1：原始值百分位（heatmap_generator_v2.py）

**关键修改**：
```python
# 修复后：在原始值上计算百分位
heatmap_resized = cv2.resize(heatmap.astype(np.float32), (224, 224))
threshold = np.percentile(heatmap_resized, threshold_percentile)  # 直接在原始值上
mask = (heatmap_resized >= threshold)
```

**效果**：+2.6%（0.2780 → 0.2851）

### 修改2：Top-k选择

```python
def generate_bboxes_topk(heatmap, top_k_ratio=0.25):
    k = int(heatmap.size * top_k_ratio)
    threshold = np.partition(heatmap.flatten(), -k)[-k]
    mask = (heatmap >= threshold)
```

**效果**：+2.6%（与修改1相同）

### 修改3：降低阈值到30%

```python
# 关键发现：75%阈值太高
# 30%阈值对应相似度0.16，恰好低于GT平均0.17
threshold = np.percentile(heatmap, 30)  # ← 30%是临界点
```

**效果**：+37.3%（0.2780 → 0.3818）

## 实验逻辑

### 测试矩阵

测试6种配置：
- **阈值**：75% / 50% / 30%
- **反转**：否 / 是

### 评估指标

- mAP@0.05（召回）
- mAP@0.10
- mAP@0.20
- mAP@0.50（精度）

## 实验结果

### 完整对比表

| 配置 | mAP@0.05 | mAP@0.10 | mAP@0.20 | mAP@0.50 |
|------|----------|----------|----------|----------|
| 原始(归一化+75%) | 0.2780 | 0.1778 | 0.0000 | 0.0000 |
| 修复(原始值75%) | 0.2851 | 0.1783 | 0.0000 | 0.0000 |
| 阈值50% | 0.2866 | 0.1124 | 0.0556 | 0.0556 |
| **阈值30%** | **0.3818** | 0.2455 | 0.2273 | **0.1667** |
| 反转+75% | 0.2869 | 0.2313 | 0.0242 | 0.0000 |
| 反转+50% | 0.4053 | 0.1364 | 0.1136 | 0.0833 |
| **反转+30%** ⭐ | **0.4167** | 0.1439 | 0.0833 | 0.0833 |

### 关键发现

#### 发现1：阈值30%是临界点

| 阈值 | mAP@0.05 | 提升 |
|------|----------|------|
| 75% | 0.2851 | +2.6% |
| 50% | 0.2866 | +3.1% |
| **30%** | **0.3818** | **+37.3%** ⚡ |

**解释**：
- 75%阈值 ≈ 0.22（排除GT平均0.17）
- 30%阈值 ≈ 0.16（包含GT）

#### 发现2：反转的协同效应

| 配置 | mAP@0.05 | mAP@0.50 |
|------|----------|----------|
| 阈值30% | 0.3818 | 0.1667 ✅ |
| 反转+30% | 0.4167 | 0.0833 |

**权衡**：
- 反转在低IoU更优（mAP@0.05）
- 不反转在高IoU更优（mAP@0.50）

## 关键结论

### 问题根源层次

| 层次 | 问题 | 修复 | 效果 |
|------|------|------|------|
| 第一层 | 阈值75%太高 | 降低到30% | +37% |
| 第二层 | 归一化破坏分布 | 原始值百分位 | +2.6% |
| 第三层 | GT相似度本身低 | 需要训练 | 待验证 |

### 最佳配置推荐

**召回场景**（检测）：
- 配置：原始RemoteCLIP + 反转 + 30%阈值
- 性能：mAP@0.05 = 0.4167

**精度场景**（验证）：
- 配置：原始RemoteCLIP + 30%阈值（不反转）
- 性能：mAP@0.50 = 0.1667

**注意**：这是在**未应用Surgery去冗余**的情况下！

## 文件输出

```
experiments/02_threshold_fix/
├── README.md (本文档)
├── evaluate_fixed_threshold.py      # 实验1.1, 1.2
├── test_low_threshold.py            # 低阈值+反转测试
├── test_inverted_heatmap.py         # 实验1.3
├── outputs/
│   ├── threshold_fix_comparison.json
│   ├── low_threshold_results.json
│   ├── comparison_*.png (3张)
│   ├── v1-normalized/ (10张)
│   ├── v2-raw-percentile/ (10张)
│   └── v2-topk/ (10张)
└── results/ (软链接到outputs)
```

## 与实验01的关系

**实验01发现**：Surgery+反转+30% = mAP@0.05 0.5000（最优）

**本实验发现**：原始+反转+30% = mAP@0.05 0.4167

**差异**：Surgery+反转比原始+反转高**20%**（0.5000 vs 0.4167）

**结论**：**Surgery+反转是真正的最佳配置！**

---

**实验时间**：约45分钟  
**实验日期**：2025-10-29  
**状态**：✅ 已完成

